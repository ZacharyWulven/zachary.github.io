---
layout: post
title: ### 2021-03-28-程序的机器级表示(四)-控制
date: 2021-03-28 15:45:30.000000000 +09:00
tag: CSApp
---

目前为止，我们只考虑直线代码行为，也就是指令一条接着一条的顺序的执行。C 语言中某些结构如条件语句、循环语句、分支语句，根据测试数据的结果决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为: 测试数据值，然后根据测试结果改变控制流或数据流。jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试结果。编译器必须产生构建在这种低级机制基础之上的指令序列来实现 c 语言的控制结构。


### 条件码
除了整数寄存器，CPU 还维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作属性，可以检测这些寄存器来执行条件分支指令
1. CF: 进位标志 最近的操作使最高位产生了进位，可以用来检测无符号操作的溢出
2. ZF: 零标志 最近的操作得出的结果为 0
3. SF: 符号标志 最近的操作得到的结果为负数
4. OF: 溢出标志 最近的操作导致一个补码溢出--正溢出或负溢出

例如： t = a + b，a b t 都是整型然后下面 C 表达式来设置条件码
 1. CF: (unsigned) t < (unsigned) a         无符号溢出
 2. ZF: t == 0                              零
 3. SF: t < 0                               负数
 4. OF: (a<0==b<0) && (t<0 !=a<0)           有符号溢出

{% highlight ruby %}
leaq 指令不改变任何条件码，因为它是用来进行地址计算的。
{% endhighlight %}

上一篇列出的 INC、DEC、NEG、NOT 等指令都会设置条件码。例如 XOR 进位标志和溢出标志会设置为 0。对于位移操作进位标志将设置为最后一个被移出的位，而溢出标志设置为 0。INC、DEC 指令会设置溢出和零标志，但是不会改变进位标志。

除了这些指令会设置条件码，还有两类指令(有8，16，32，64位形式) 只设置条件码而不改变任何其他寄存器。
1. CMP 指令根据两个操作数之差来设置条件码，除只设置条件码而不更新寄存器外 CMP 指令与 SUB 指令行为是一样的，在 ATT 格式中，列出操作数的顺序是相反的，如果两个操作数相等，这些指令会将零标志设置为 1，其他的标志可以用来确定两个操作数之间的大小关系。cmpb、cmpw、cmpl、cmpq
2. TEST 指令与 AND 指令一样，典型用法两个操作数是一样的，如 testq %rax, %rax 用来检测 %rax 是负数、0 还是正数，或其中一个操作数是掩码，用来指示哪些位应该被测试。testb、testw、testl、testq

### 访问条件码
条件码通常不会直接读取，常用的使用方法有三种：
1. 可以根据条件码的某种组合，将一个字节设置为 0 或 1，我们将这一整类指令称为 SET。它们之间的区别在于它们考虑的条件码组合是什么，这些指令的后缀指明了它们所考虑的条件码组合，这些指令后缀表示不同的条件而不是操作数大小。了解这些很重要。例如指令 setl 和 setb 表示小于时设置 set less 即 setl，低于时设置 set below 即 setb，而不是设置长字和设置字节。一条 SET 指令的目的操作数是低位单字节寄存器元素之一（如 %al、%bl 等）， 或是一个字节的内存位置，指令会将这个字节设置为 0 或 1。
2. 可以条件跳转到程序的某个其他的部分
3. 可以有条件的传送数据

SET 指令根据条件码的某个组合将一个字节设置为 0 或 1
{% highlight ruby %}
指令             同义名         效果                        设置条件
sete   D        setz          D<- ZF                      相等/零 
setne  D        setnz         D<- ~ZF                     不等/非零

sets   D                      D<- SF                      负数
setns  D                      D<- ~SF                     非负数

setg   D        setnle        D<- ~(SF ^ OF) & ~ZF        大于(有符号>)
setge  D        setnl         D<- ~(SF ^ OF)              大于等于(有符号>=)
setl   D        setnge        D<- SF ^ OF                 小于(有符号<)
setle  D        setng         D<- (SF ^ OF) | ZF          小于等于(有符号<=)

seta   D        setnbe        D<- ~CF & ~ZF               超过(无符号>)
setae  D        setnb         D<- ~CF                     超过或相等(无符号>=)
setb   D        setnae        D<- CF                      低于(无符号<)
setbe  D        setna         D<- CF | ZF                 低于或相等(无符号<=)
{% endhighlight %}

一个 C 语言表达式 a < b 典型指令
{% highlight ruby %}
a < b
int comp(data_t a, data_t b)
a in %rdi, b in %rsi
comp:
cmpq     %rsi,%rdi            compare a:b
setl     %al                  set low-order byte of %eax to 0 or 1
movzbl   %al, %eax            clear rest of %eax (and rest of %rax)
ret
movzbl 指令不仅会把 %eax 的高3个字节清零，还会把寄存器 %rax 高 4 个字节都清零。底层机器指令可能有多个名字·，称为同义名 setg 表示“设置大于” 和 setnle 表示“设置不小于等于” 就是同一个指令。
{% endhighlight %}

对于无符号比较，CMP 指令会设置进位标志，因而无符号比较使用的是进位标志和零标志的组合。注意到机器代码如何区分有符号和无符号是很重要的，同 C 语言不通机器代码不会将每个程序值都和一个数据类型联系起来，相反大多情况机器代码对于有符号和无符号都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。有些情况要用不同指令处理有符号和无符号操作，如不同版本的右移、除法、乘法等。

{% highlight ruby %}
汇编代码不会记录程序值的类型，理解这点很重要。不同指令确定操作数的大小以及是有符号还是无符号。
{% endhighlight %}

例如下边汇编代码确定 a 的类型
{% highlight ruby %}
int test(data_t a) {
return a TEST 0
}
testq  %rdi, %rdi
setge  %al

解析：testq 确定是 64 位操作，a 应该是 64 位的，setge 表示对有符号的比较所以 a 可能类型是 long
{% endhighlight %}
