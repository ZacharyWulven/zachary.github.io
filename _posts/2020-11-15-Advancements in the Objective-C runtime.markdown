---
layout: post
title: ### Advancements in the Objective-C runtime
date: 2020-11-15 22:23:30.000000000 +09:00
tag: iOS WWDC
---

距离 WWDC2020 过了也快小半年，由于前段时间项目比较忙事情比较多也没有太多时间更新。
不过最近节奏还可以抽空把 WWDC2020 自己感兴趣的内容记录一下。
书归正传, 开始今天的话题，也就是 Objective-C runtime 变化。

#### 一、三大变化
{% highlight ruby %}
1 类的运行时数据结构变化
2 方法列表变化
3 Tagged Pointer 格式变化
{% endhighlight %}


#### 二、clean memory 和 dirty memory
{% highlight ruby %}
这次优化都是围绕 clean memory 和 dirty memory
{% endhighlight %}

clean memory 指加载后不会发生更改的内存，class_ro_t 就是 clean memory 因为它是只读的。
clean memory 可以移除，如果你需要再从磁盘中重新加载。

dirty memory 指在进程运行时会发生更改的内存，例如创建一个新的方法缓存并从类中指向它，class_rw_t 就是 dirty memeory。
dirty memory 比 clean memory 代价昂贵，只要进程在运行 它就必须一直存在。


#### 三、类的运行时数据结构变化
类结构有指向元类，超类和方法缓存的指针, 还有一个指针指向更多数据 class_ro_t，swift 和 oc 使用一样的底层基础结构。

当一个类首次被使用 运行时会为它分配额外的存储容量，也就是 class_rw_t 用于读取-编写数据, class_rw_t 中存储了只有在运行时才会生成的信息, 所有类都会链接成一个数状结构，这是通过使用 First Subclass 和 Next Sibling Class 指针实现，这允许运行时遍历当前使用的所有类，追踪使用类的信息，这对于方法缓存无效非常有用。

只有 swift 类会使用 demangled name 字段, swift 一般不需要这个字段，除非有东西询问它们的 OC 名称时候才需要，所以可以拆掉平时不用的部分, 从而减少 class_rw_t 大小。

根据苹果给出的数据，大约 90% 的类从来不需要这些扩展数据，在系统范围内可节省大约 14 MB。

你可以运行一个命令，在任何 mac 上都有，叫 heap。heap 允许你检查正在运行的进程所使用的堆内存。
$heap Mail | egrep 'class_rw|COUNT'

于是 class_rw_ext_t 出现了，它节省了 dirty memory 的大小
现在很多从类中获取数据的代码，必须同时处理那些有扩展和没有扩展（class_rw_ext_t）数据的类，当然运行时会为你想往常一样处理一切，从外部看和往常一样，只是使用更少的内存。任何试图直接访问这些数据结构的代码，都将在今年停止工作。


#### 四、方法列表变化
每个方法都包含 3 个信息
{% highlight ruby %}
1 方法名称或叫选择器，选择器是 string 具有唯一性，所以他们可以使用指针相当来比较。
2 方法类型编码 这是表示参数和返回值的字符串，是运行时和消息转发所必需的。
3 指向方法实现的指针，方法实际代码，当你写一个方法时候 会被编译成一个 c 函数。
{% endhighlight %}

以 init 为例子：
有三个方法表条目，每一个都是一个指针 所以在 64 位 就是 8+8+8 = 24 字节。
相当于每个方法表条目占 24 字节, 属于 clean memory 它并不是免费的，它必须从磁盘中加载并且使用时会占用内存。
虚拟地址空间它需要 64 位来寻址, 在这个地址内存中分了几个部分堆、栈，可执行文件和库二进制图像。而二进制图像可以加载到内存中任何位置，这取决于动态链接器决定把它放在哪里,  这意味着链接器需要将指针解析到图像中，并在加载时将其修正为指向其在内存中的实际位置，这也是有代价的。

{% highlight ruby %}
一个来自二进制文件的类方法条目,永远只指向该二进制文件内的方法实现，不可能使一个方法的元数据存在于一个二进制文件中，而实现它的代码在另一个二进制文件中。
{% endhighlight %}

{% highlight ruby %}
这意味着方法列表条目实际上不需要能够引用整个 64 为地址空间，它只要能引用自己的二进制中的函数，而这些函数总是在附近的, 因此 无需使用绝对的 64 位地址，它们可以使用 32 位的相对偏移。
{% endhighlight %}

这样做的好处：
{% highlight ruby %}
1 偏移量总是相同的 不管镜像在哪里加载到内存中，所以他们从磁盘加载后不需要进行修正，而由于他们不需要修正了所以他们可以存储在真正的只读内存中这样更安全，当然使用 32 位偏移 意味着将 64 位内存量减少了一半。
在一台经典 iPhone 中系统范围内测量了大约 80MB 的这些方法，他们的尺寸节省了 40MB。
2 swizzling 二进制中的方法列表，现在不能引用完整的地址空间，但如果你 swizzling 一个方法它就可以在任何地方实施, 而且苹果希望保持这些方法列表为只读, 所以创建了一个全局表，这全局表将方法映射到它们被 swizzle 的实施上。
swizzle 用的相对较少，所以全局表最终变化不会很大，内存每次都是按页面来 “弄脏”。
使用旧的方法列表 swizzle 一个方法会 “弄脏” 它所在的整个页面，一次 swizzle 就会导致产生千字节的 dirty memory。
有了整个全局表 我们只需要位一个额外的表的条目付出代价,但一切都会按照和以前一样运行。
这些相对的方法列表 在新的 OS 版本上是受支持的 iOS 14、macOS Big Sur、tvOS 14、watchOS7。
当你使用相应的最小部署 target 进行构建时候 工具会自动在你的二进制文件中生成相对方法列表。
如果你需要针对旧的 OS 版本的方法列表也不用担心，Xcode 也会生成旧方式的方法列表格式，系统可以在同一个 app 支持新旧两种方式的方法列表
不过如果你针对 iOS 14、macOS Big Sur、tvOS 14、watchOS7 进行部署构建 ，你的二进制文件会变小 而且使用的内存也会变少。
最小部署 不仅仅关系到你有哪些 SDK 可以使用 如果 Xcode 知道不需要支持旧的 OS 版本，那它可以发布更好的优化代码或数据。

有一个事情注意，使用一个比你打算使用的更新的部署目标进行构建， Xcode 一般会阻止这种 case 但也可能漏掉，比如你在其他地方构建自己的库或框架然后把它带进来 在旧的 OS 中运行时,可能造成 旧的 OS 对新的一无所知 旧方式试图基于指针的方法来解释他们，意味着 它将尝试把一对 32 位的字段作为 64 位的指针来读取，这样的结果是两个整数作为一个指针粘在一起，这样就会造成 crash。
这个时候 坏指针就像两个 32 bit 值平滑在一起, 所以如果对数据进行挖掘的话，就会有问题 推荐总是使用 runtime 提供的 API，如 method_getName 等。
{% endhighlight %}


#### 五、Tagged Pointer
由于对齐要求 低位始终为 0
在 Inter 平台低位为标志位：
对象总在指针大小倍数的一个地址中, 由于地址空间有限高位始终为 0，实际上不会用到 2^64, 高位和低位总是 0，选择一位并把它们设置为 1 ，可以让我们知道它不是一个指针，这些值实际上是通过与进程启动时初始化的随机值相结合而被混淆的。

低位设置为 1 表示 Tagged Pointer，接下来 3 位是标签号，用来表示 Tagged Pointer 类型， 如 3 表示它是一个 NSNumber， 6 为 NSDate，由于有 3 个标签位 所以有 8 种可能的标签类型，剩下的位是有效负载 payload ，这是特定类型可以随意使用的数据，对于 NSNumber 有些特殊 使用额外 8 位来作为扩展标签 来编码类型，但是会减少 payload 空间。

在 ARM 平台高位为标志位：
高位 1 位 Tagged Pointer ，同 Inter 平台一样，也是有扩展标签的。
为什么 ARM 平台是高位为 1 ？这是对 objc_msgSend 的一个小优化, 苹果希望 msgSend 中最常见的路径可以尽可能的快，而最常见的路径是一个普通指针。
当使用高位时候 可以通过一次比较对这两个进行检查。
if (ptrValue <= 0) is Tagged Pointer Or nil，相对于两个分支检查 nil 和 tagged 这样就节省了一个条件分支。


2020 改变
{% highlight ruby %}
标签位保持在最高位，这样做高位还是为了 msgSend 优化
标签号现在移到了最小边 3 个位, 扩展标签随在标签位后。
现有工具 比如动态链接  会忽略普通指针前 8 位 这是由于 一个名为 Top Byte Ignore 的 ARM 特性，苹果会把扩展标签放在 Top Byte Ignore 位。
对于一个对齐的指针 底部 3 个位总是 0，但我们可以改变这点 只要通过在指针上添加一个小数字，我们将添加 7 将低位设置为 1，7 表示这是一个扩展标签，这意味着可以将上面的这个指针放入一个扩展标签指针有效负载中，这个结果是一个 Tagged Pointer 以及其有效负载中包含一个正常指针，它开启了Tagged Pointer 能力 引用二进制文件中的常量数据能力，如字符串或其他数据结构，否则他们将不得不占用 dirty memory
{% endhighlight %}


#### 六、总结
{% highlight ruby %}
1 你不需做什么就能获得改进，如果说要做应该只是最小部署的问题
2 不要直接读取内部的位，总是使用苹果的 API
{% endhighlight %}
