---
layout: post
title: ### 程序的机器级表示(一
date: 2021-01-07 22:45:30.000000000 +09:00
tag: CSApp
---
### 机器代码
有时指目标代码，有时指文本格式的汇编代码。ARM 是 Acorn RISC Machine 的缩写。RISC 精简指令集计算机。
汇编代码表示非常接近机器代码，与机器代码的二进制相比，具有更好的可读性文本格式。
#### 对机器编程来说其中两种抽象尤为重要：
1. 由指令集体系结构或指令架构(Instruction Set Architecture，ISA) 来定义机器级程序的格式和行为，它定义了处理器状态，指令的格式以及每条指令对状态的影响，大多数 ISA 将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束下一条再开始。处理器硬件远比描述的精细复杂，他们并发地执行许多指令，但是可以采取措施保证整体行为与 ISA 指定的顺序完全一致。
2. 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

{% highlight ruby %}
1 机器编程的基本原理主要思想是通过访问寄存器到的一些状态
2 其实 cc 就是 GCC 编译器，可以用 cc 启动
{% endhighlight %}

### 处理器状态
1. 程序计数器（通常称为 PC）在 x86-64 中用 %rip 表示，给出将要执行的下一条指令在内存中的地址
2. 整数寄存器文件包含 16 个命名位置，分别存储 64 位的值，这些寄存器可以存储地址(类似 c 指针)或整数数据，有些寄存器用来记录某些重要的程序状态，其他的寄存器用来保存临时数据，如过程的参数和局部变量以及函数返回值
3. 条件码寄存器保存着最近执行的算术或逻辑指令的状态和信息，用来实现控制或数据流中的条件变化，如 if、while
4. 一组向量寄存器可以存放一个或多个整数或浮点数的值

### 内存
内存实际是用不同方式实现的虚构对象，操作系统和硬件之间存在一种协作称为虚拟内存，让每个程序看起来像有自己独立的字节数组。
{% highlight ruby %}
1 没有操作缓存的指令，你无法之间访问缓存
2 内存是你可以逻辑的认为只是一个字节数组，这就是机器级程序员看到的
{% endhighlight %}

### 生成程序的过程
1. 采用 C 并实际生成汇编代码 （编译 gcc -Og -S）
2. 通过汇编程序运行它，接受文本表示的指令并将其转换为实际的字节形式 （汇编 gcc or as）
3. 链接器将不同文件融合在一起，包含你的单独文件 （Linker gcc or ld）
4. 实际运行程序时，有一些库在程序首次开始时动态导入

{% highlight ruby %}
机器代码重要的一点就是程序计数器 PC 告诉你:
1 下一个指令是什么
2 下一个指令在内存中的位置
然后有一组寄存器供使用，可以把它们看成非常小的内存位置
{% endhighlight %}

### 介绍几个指令
1. pushq 将东西推到栈中
2. mov 将它从一个地方复制到另一个地方
3. call 调用
4. pop pushq 的反操作
5. ret 从一个函数返回

### 生成汇编
$ gcc -Og -S sum.c （将 c 代码转化为汇编生成 sum.s 调用 gcc 是调用整个编译序列）
#### 参数：
1. -S stop 只做第一部，把 c 转为汇编
2. -Og 告诉编译器做什么优化规范，如果什么都不加 会产出无优化过的代码，非常难读
3. -O1 打开优化器
4. -O2 打开优化器
5. -O Optimize
{% highlight ruby %}
.s 都是汇编文件
d 后缀是反汇编文件
{% endhighlight %}

### 汇编与 C 有什么不同？
1. 汇编有很多不同类型的整数数据类型，有 1、2、4、8 字节的
2. 在整数数据类型中它们不区分有符号与无符号的存储方式，甚至地址或指针都是以数字形式在计算机中存储的
3. 浮点数以非常不同的方式处理事宜不同的寄存器组
4. x86 下有的指令只有 1 个字节，有的可能最多 15 字节
{% highlight ruby %}
数组和结构体不存在于机器语言
{% endhighlight %}

### 反汇编
将工程从目标代码转回到汇编代码，会有所丢失跟正常的汇编代码有些不同
#### $ gcc -Og sum.c -o sum (sum 是一个二进制)
####  $ objdump -d sum > sum.d (会输出程序的反汇编结果)
#### 所有以“.”开头的行都是指导汇编器和链接器工作的伪指令，可以忽略
{% highlight ruby %}
push    %rbx
mov     %rdx, %rbx
callq   9 <multstore+0x9>
mov     %rax,(%rbx)
pop     %rbx
retq
{% endhighlight %}
反汇编代码会省略指令后边的 “q” 如 pushq 变成 push，但 call 和 ret 指令后会加 “q” 变成 callq，retq

### 链接器
链接器将地址显示了出来 如第四行
{% highlight ruby %}
push    %rbx
mov     %rdx, %rbx
callq   40058b <mult2>
mov     %rax,(%rbx)
pop     %rbx
retq
nop
nop
{% endhighlight %}
#### 链接器的作用之一就是为函数调用找到匹配的函数可执行代码的位置
#### 反汇编可能生成 nop 指令，但如果在 ret 后就不影响，因为函数已经 return 如第 8、9行

### GDB 调试
(gdb)disassemble sumstore （sumstore 是个函数，输出 sumstore 反汇编代码，multstore.o 文件）
#### x/14xb sumstore
#### x 表示从函数 multstore 所处的地址开始的 14 个十六进制格式表示 (简写 x)的字节(简写 b)

### 寄存器
{% highlight ruby %}
1 使用 %r 版本将得到 64 位
2 使用 %e 版本将得到 32 位，%e 版本只是 %r 版本的实体的低 32 位
3 %rsp 是栈指针 , 不把它作为任何旧用途
4 PC 是 %rip
{% endhighlight %}
